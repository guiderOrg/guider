diff --git a/arch/arm/kernel/stacktrace.c b/arch/arm/kernel/stacktrace.c
index 92b7237..19bc879 100644
--- a/arch/arm/kernel/stacktrace.c
+++ b/arch/arm/kernel/stacktrace.c
@@ -1,7 +1,9 @@
 #include <linux/export.h>
 #include <linux/sched.h>
 #include <linux/stacktrace.h>
+#include <linux/uaccess.h>
 
+#include <asm/uaccess.h>
 #include <asm/stacktrace.h>
 #include <asm/traps.h>
 
@@ -177,3 +179,94 @@ void save_stack_trace(struct stack_trace *trace)
 }
 EXPORT_SYMBOL_GPL(save_stack_trace);
 #endif
+
+#ifdef CONFIG_USER_STACKTRACE_SUPPORT
+/*
+ * User-stack-tracer for ARM archtecture
+ * 1. enable CONFIG_USER_STACKTRACE_SUPPORT option in Kconfig
+ * 2. patch and rebuild kernel
+ * 3. build target binary with -g -rdynamic -fno-omit-frame-pointer option
+ */
+struct stack_frame_user {
+	unsigned long next_fp;
+	unsigned long pc;
+};
+
+static int copy_stack_frame_user(const void __user *fp,
+	struct stack_frame_user *frame)
+{
+	int ret = 0;
+
+	if (!access_ok(VERIFY_READ, fp, sizeof(*frame)))
+		return 0;
+
+	pagefault_disable();
+
+	ret = __copy_from_user_inatomic(frame, fp, sizeof(*frame));
+
+	pagefault_enable();
+
+	return !ret;
+}
+
+static inline void __save_stack_trace_user(struct stack_trace *trace)
+{
+	int nr_try = 0;
+	int addrSize = sizeof(unsigned long);
+	struct stack_frame_user frame;
+
+	const struct pt_regs *regs = task_pt_regs(current);
+	const void __user *fp = (const void __user *)regs->ARM_fp;
+	const void __user *pc = (const void __user *)regs->ARM_pc;
+	const void __user *lr = (const void __user *)regs->ARM_lr;
+	const void __user *sp = (const void __user *)regs->ARM_sp;
+
+	/* Save pc and lr */
+	trace->entries[trace->nr_entries++] = (unsigned long)pc;
+	if (lr)
+		trace->entries[trace->nr_entries++] = (unsigned long)lr;
+
+	/* Get second frame pointer */
+	if (!copy_stack_frame_user(fp, &frame)) {
+		return;
+	} else if (frame.next_fp > (unsigned long)sp) {
+		fp = (const void __user *)frame.next_fp;
+	}
+
+	while (trace->nr_entries < trace->max_entries &&
+		nr_try++ < trace->max_entries) {
+
+		if (!copy_stack_frame_user(fp - addrSize, &frame))
+			break;
+
+		if (!frame.pc) {
+			break;
+		} else if ((unsigned long)frame.pc & 0x1) {
+			/*
+			 * Thumb code is not supported because
+			 * FP register is not used in thumb mode.
+			 * so that it is impossible to know
+			 * base addr or size of stack frame.
+			 */
+			trace->entries[trace->nr_entries++] = 0xC0FFEE;
+			break;
+		} else if (frame.pc < frame.next_fp) {
+			trace->entries[trace->nr_entries++] = frame.pc;
+			fp = (const void __user *)frame.next_fp;
+		} else {
+			break;
+		}
+	}
+}
+
+void save_stack_trace_user(struct stack_trace *trace)
+{
+	if (current->mm) {
+		__save_stack_trace_user(trace);
+
+		if (trace->nr_entries < trace->max_entries)
+			trace->entries[trace->nr_entries++] = ULONG_MAX;
+	}
+}
+EXPORT_SYMBOL_GPL(save_stack_trace_user);
+#endif
